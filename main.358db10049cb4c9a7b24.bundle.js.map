{"version":3,"file":"main.358db10049cb4c9a7b24.bundle.js","sources":["webpack:///./src/rpc.ts"],"sourcesContent":["import get from \"lodash.get\";\nimport set from \"lodash.set\";\nimport short from \"short-uuid\";\n\nimport { isTrustedRemote } from \"./helpers\";\nimport { actions, events, IRPCRequestPayload, IRPCResolvePayload, ISchema } from \"./types\";\n\n/**\n * for each function in the schema subscribe to an event that the remote can call and\n * listen for calls from the remote. When called execute the function and emit the results.\n *\n * @param methods an array of method ids from the local schema\n * @param _connectionID\n * @return a function to cancel all subscriptions\n */\nexport function registerLocalMethods(schema: ISchema, methods: any[], _connectionID: string): any {\n  const listeners: any[] = [];\n  methods.forEach((methodName) => {\n\n    // handle a remote calling a local method\n    async function handleCall(event: any) {\n      const { action, callID, connectionID, callName, args } = event.data as IRPCRequestPayload;\n\n      if (action !== actions.RPC_REQUEST) return;\n      if (!isTrustedRemote(event)) return;\n      if (!callID || !callName) return;\n      if (callName !== methodName) return;\n      if (connectionID !== _connectionID) return;\n\n      // run function and return the results to the remote\n      try {\n        const result = await get(schema, methodName)(...args);\n        event.source.postMessage({\n          action: actions.RPC_RESOLVE,\n          callID,\n          callName,\n          connectionID,\n          result,\n        });\n      } catch (error) {\n        event.source.postMessage({\n          action: actions.RPC_REJECT,\n          callID,\n          callName,\n          connectionID,\n          error,\n        });\n      }\n    }\n\n    // subscribe to the call event\n    window.addEventListener(events.MESSAGE, handleCall);\n    listeners.push(() => window.removeEventListener(events.MESSAGE, handleCall));\n  });\n\n  return () => listeners.forEach((unregister) => unregister());\n}\n\n/**\n * create a remote object from the remote schema and methods. Functions in that object will emit an\n * event to the remote to execute an RPC.\n *\n * @param schema\n * @param _connectionID\n * @param remote\n */\nexport function registerRemoteMethods(schema: ISchema, methods: any[], _connectionID: string, target: any) {\n  const remote = Object.assign({}, schema);\n  const listeners: Array<() => void> = [];\n  methods.forEach((methodName) => {\n    const rpc = createRPC(methodName, _connectionID, target, listeners);\n    set(remote, methodName, rpc);\n  });\n  return { remote, unregisterRemote: () => listeners.forEach((unregister) => unregister()) };\n}\n\n/**\n * create a function that will call the remote when invoked with the required arguments\n * listen to the event returned by the remote and resolve the promise\n *\n * @param _callName\n * @param _connectionID\n * @param remote\n */\nexport function createRPC(_callName: string, _connectionID: string, target: any, listeners: Array<() => void>) {\n  return (...args: any) => {\n    return new Promise((resolve, reject) => {\n      const callID = short.generate();\n\n      // on RPC response\n      function handleResponse(event: any) {\n        const { callID, connectionID, callName, result, error, action } = event.data as IRPCResolvePayload;\n\n        if (!isTrustedRemote(event)) return;\n        if (!callID || !callName) return;\n        if (callName !== _callName) return;\n        if (connectionID !== _connectionID) return;\n\n        // resolve the response\n        if (action === actions.RPC_RESOLVE) return resolve(result);\n        if (action === actions.RPC_REJECT) return reject(error);\n      }\n\n      // send the RPC request with arguments\n      const payload = {\n        action: actions.RPC_REQUEST,\n        args,\n        callID,\n        callName: _callName,\n        connectionID: _connectionID,\n      };\n\n      window.addEventListener(events.MESSAGE, handleResponse);\n      listeners.push(() => window.removeEventListener(events.MESSAGE, handleResponse));\n      target.postMessage(payload, target.origin);\n    });\n  };\n}\n"],"mappings":"AAAA","sourceRoot":""}